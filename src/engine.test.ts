import { Engine } from './engine';
import { BasketryError, File, Parser, Rule, Violation } from './types';

import { setParser } from './test-modules/parser';
import { setFiles } from './test-modules/generator';
import { setViolations as setRuleViolations } from './test-modules/rule';
import { Service } from './ir';
import { join, relative, sep } from 'path';
import { FileSystem } from './file-system';

import { PathLike } from 'fs';
import { fs, vol } from 'memfs';
import { EOL } from 'os';

function osPath(path: string): string {
  return path.split('/').join(sep);
}

/**
 * @deprecated Use Engine instead which automatically creates a .gitattributes file
 */
export function withGitattributes(files: File[], output?: string): File[] {
  if (!files.length) return files;

  const warning = () => `# This code was generated by ${
    require('../package.json').name
  }@${require('../package.json').version}
#
# Changes to this file may cause incorrect behavior and will be lost if
# the code is regenerated.
#
# To learn more, visit: ${require('../package.json').homepage}

`;

  return [
    ...files,
    {
      path: [output, '.gitattributes'].filter((x): x is string => !!x),
      contents:
        warning() +
        files
          .map(
            (file) =>
              `${
                output
                  ? relative(output, join(...file.path))
                  : join(...file.path)
              } linguist-generated=true${EOL}`,
          )
          .join(''),
    },
  ];
}

class MemoryFileSystem implements FileSystem {
  constructor(private readonly overrides?: Partial<FileSystem>) {}
  mkdir(
    path: PathLike,
    options?: { recursive?: boolean },
  ): Promise<string | undefined> {
    const fn = this.overrides?.mkdir ?? fs.promises.mkdir;
    return fn(path, options);
  }
  readFile(file: PathLike): Promise<string | Buffer> {
    const fn = this.overrides?.readFile ?? fs.promises.readFile;
    return fn(file);
  }
  unlink(file: PathLike): Promise<void> {
    const fn = this.overrides?.unlink ?? fs.promises.unlink;
    return fn(file);
  }
  writeFile(file: PathLike, data: string): Promise<void> {
    const fn = this.overrides?.writeFile ?? fs.promises.writeFile;
    return fn(file, data);
  }
}

const fsPromises = new MemoryFileSystem();
const projectDirectory = `${sep}some${sep}project${sep}path`;

describe('engine', () => {
  beforeEach(() => vol.reset());

  it('returns the relative source path', () => {
    // ARRANGE
    const engine = new Engine(
      {
        projectDirectory,
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: nullParser,
        generators: [],
        rules: [],
      },
      fsPromises,
    );

    // ACT & ASSERT
    expect(engine.sourcePath).toEqual('some-file.ext');
  });

  describe('runParser', () => {
    it('returns a parsed service', async () => {
      // ARRANGE
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [],
          rules: [],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();

      // ASSERT
      expect(engine.service).toEqual<Service>({
        basketry: '0.2',
        kind: 'Service',
        sourcePaths: ['some-file.ext'],
        title: { kind: 'StringLiteral', value: 'null' },
        majorVersion: { kind: 'IntegerLiteral', value: 1 },
        interfaces: [],
        types: [],
        enums: [],
        unions: [],
      });
    });

    it('returns and error when the parser throws', async () => {
      // ARRANGE
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: () => {
            throw new Error('Parser error');
          },
          generators: [],
          rules: [],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();

      // ASSERT
      expect(engine.service).toBeUndefined();
      expect(engine.errors).toEqual<BasketryError[]>([
        {
          code: 'PARSER_ERROR',
          message: 'Parser error',
          filepath: 'some-file.ext',
        },
      ]);
    });

    it.todo('replaces # with the source path in the returned service');
    it.todo('replaces # with the source path in the returned violations');
    it.todo('considers paths to be relative to the project directory');
    it.todo('handles multi-file SDLs');
  });

  describe('runRules', () => {
    it('returns violations returned by rules', async () => {
      // ARRANGE
      const violation: Violation = {
        code: 'test-rule',
        message: 'This is a test rule violation',
        severity: 'error',
        range: {
          start: { line: 1, column: 1, offset: 0 },
          end: { line: 1, column: 1, offset: 0 },
        },
        sourcePath: 'some-file.ext',
      };

      const rule: Rule = () => [violation];

      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [],
          rules: [rule],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();

      // ASSERT
      expect(engine.violations).toEqual<Violation[]>([violation]);
    });

    it('deduplicates multiple identical violations', async () => {
      // ARRANGE
      const violation1: Violation = {
        code: 'test-rule',
        message: 'This is a test rule violation',
        severity: 'error',
        range: {
          start: { line: 1, column: 1, offset: 0 },
          end: { line: 1, column: 1, offset: 0 },
        },
        sourcePath: 'some-file.ext',
      };
      const violation2: Violation = {
        code: 'test-rule',
        message: 'This is a test rule violation',
        severity: 'error',
        range: {
          start: { line: 1, column: 1, offset: 0 },
          end: { line: 1, column: 1, offset: 0 },
        },
        sourcePath: 'some-file.ext',
      };

      const rule1: Rule = () => [violation1];
      const rule2: Rule = () => [violation2];

      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [],
          rules: [rule1, rule2],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();

      // ASSERT
      expect(engine.violations).toEqual<Violation[]>([violation1]);
    });
  });

  describe('runGenerators', () => {
    it('returns files', async () => {
      // ARRANGE
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.files).toEqual<File[]>([
        expect.objectContaining({
          path: [...generatedFile.path],
        }),
        expect.objectContaining({ path: ['.gitattributes'] }),
      ]);
    });

    it('returns file paths prepended with the output path', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          output,
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.files).toEqual<File[]>([
        expect.objectContaining({
          path: ['some', 'output', 'path', ...generatedFile.path],
        }),
        expect.objectContaining({
          path: ['some', 'output', 'path', '.gitattributes'],
        }),
      ]);
    });
  });

  describe('compareFiles', () => {
    it('identifies files that have been added', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();

      // ASSERT
      expect(engine.changes).toEqual(
        expect.objectContaining({
          [osPath('some/output/path/generated/file.ext')]: 'added',
        }),
      );
    });

    it('identifies files that have been modified', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/generated/file.ext`)]:
          'Old content',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();

      // ASSERT
      expect(engine.changes).toEqual(
        expect.objectContaining({
          [osPath(`${output}/generated/file.ext`)]: 'modified',
        }),
      );
    });

    it('identifies files that have been removed', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/.gitattributes`)]:
          'removed.ext linguist-generated=true',
        [osPath(`${projectDirectory}/${output}/removed.ext`)]:
          'this file will be removed',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();

      // ASSERT
      expect(engine.changes).toEqual(
        expect.objectContaining({
          [osPath(`${output}/removed.ext`)]: 'removed',
        }),
      );
    });

    it('identifies files that are unchanged', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/generated/file.ext`)]:
          'Generated content',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();

      // ASSERT
      expect(engine.changes).toEqual(
        expect.objectContaining({
          [osPath(`${output}/generated/file.ext`)]: 'no-change',
        }),
      );
    });

    describe('equivalence', () => {
      it('considers files equivalent when they have the exact same contents', async () => {
        // ARRANGE
        const output = osPath(`some/output/path`);
        vol.fromJSON({
          [osPath(
            `${projectDirectory}/${output}/generated/file.ext`,
          )]: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
        });
        const generatedFile: File = {
          path: ['generated', 'file.ext'],
          contents: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
        };
        const engine = new Engine(
          {
            projectDirectory,
            sourcePath: 'some-file.ext',
            sourceContent: 'some content',
            parser: nullParser,
            generators: [() => [generatedFile]],
            rules: [],
            output,
          },
          fsPromises,
        );

        // ACT
        await engine.runParser();
        await engine.runRules();
        await engine.runGenerators();
        await engine.compareFiles();

        // ASSERT
        expect(engine.changes).toEqual(
          expect.objectContaining({
            [osPath(`${output}/generated/file.ext`)]: 'no-change',
          }),
        );
      });
      describe('single-SLOC files', () => {
        it('considers them equivalent if the first lines are equal', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 1${EOL}`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'no-change',
            }),
          );
        });
        it('considers them NOT equivalent if the first lines differ', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 2${EOL}`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'modified',
            }),
          );
        });
      });
      describe('multi-SLOC files', () => {
        it('considers them equivalent if all lines after the first are equal', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 2${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'no-change',
            }),
          );
        });
        it('considers them NOT equivalent any line after the first differs', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 1${EOL}Line two - version 2${EOL}Line three - version 2${EOL}`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'modified',
            }),
          );
        });
        it('considers them NOT equivalent if the new file is single-SLOC', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 1${EOL}`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'modified',
            }),
          );
        });
        it('considers them NOT equivalent if the new file is single-line', async () => {
          // ARRANGE
          const output = osPath(`some/output/path`);
          vol.fromJSON({
            [osPath(
              `${projectDirectory}/${output}/generated/file.ext`,
            )]: `Line one - version 1${EOL}Line two - version 1${EOL}Line three - version 1${EOL}`,
          });
          const generatedFile: File = {
            path: ['generated', 'file.ext'],
            contents: `Line one - version 1`,
          };
          const engine = new Engine(
            {
              projectDirectory,
              sourcePath: 'some-file.ext',
              sourceContent: 'some content',
              parser: nullParser,
              generators: [() => [generatedFile]],
              rules: [],
              output,
            },
            fsPromises,
          );

          // ACT
          await engine.runParser();
          await engine.runRules();
          await engine.runGenerators();
          await engine.compareFiles();

          // ASSERT
          expect(engine.changes).toEqual(
            expect.objectContaining({
              [osPath(`${output}/generated/file.ext`)]: 'modified',
            }),
          );
        });
      });
    });
  });

  describe('commitFiles', () => {
    it('writes added files to the file system', async () => {
      // ARRANGE
      const output = osPath(`some/output/path`);
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();
      await engine.commitFiles();

      // ASSERT
      console.log(vol.toJSON());
      expect(Object.keys(vol.toJSON())).toEqual([
        osPath(`${projectDirectory}/${output}/generated/file.ext`),
        osPath(`${projectDirectory}/${output}/.gitattributes`),
      ]);
    });

    it('writes modified files to the file system', async () => {
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/generated/file.ext`)]:
          'Old content',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();
      await engine.commitFiles();

      // ASSERT
      console.log(vol.toJSON());
      expect(Object.keys(vol.toJSON())).toEqual([
        osPath(`${projectDirectory}/${output}/generated/file.ext`),
        osPath(`${projectDirectory}/${output}/.gitattributes`),
      ]);
    });

    it('unlinks removed files to the file system', async () => {
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/.gitattributes`)]:
          'removed.ext linguist-generated=true',
        [osPath(`${projectDirectory}/${output}/removed.ext`)]:
          'this file will be removed',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        fsPromises,
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();
      await engine.commitFiles();

      // ASSERT
      console.log(vol.toJSON());
      const actualFilepaths = Object.keys(vol.toJSON());
      const expectedFiles = [
        osPath(`${projectDirectory}/${output}/generated/file.ext`),
        osPath(`${projectDirectory}/${output}/.gitattributes`),
      ];
      expect(actualFilepaths.length).toEqual(expectedFiles.length);
      expect(actualFilepaths).toEqual(expect.arrayContaining(expectedFiles));
    });

    it('returns an error when a removed file cannot be unlinked', async () => {
      const output = osPath(`some/output/path`);
      vol.fromJSON({
        [osPath(`${projectDirectory}/${output}/.gitattributes`)]:
          'removed.ext linguist-generated=true',
        [osPath(`${projectDirectory}/${output}/removed.ext`)]:
          'this file will be removed',
      });
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        new MemoryFileSystem({
          unlink: () => {
            throw new Error('>>>> CANNOT UNLINK <<<<');
          },
        }),
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();
      await engine.commitFiles();

      // ASSERT
      console.log(vol.toJSON());
      expect(engine.errors).toEqual([
        {
          code: 'WRITE_ERROR',
          message: 'Unable to remove file. (>>>> CANNOT UNLINK <<<<)',
          filepath: osPath(`${output}/removed.ext`),
        },
      ]);
      const actualFilepaths = Object.keys(vol.toJSON());
      const expectedFiles = [
        osPath(`${projectDirectory}/${output}/removed.ext`), // Expect the file to still exist
        osPath(`${projectDirectory}/${output}/generated/file.ext`),
        osPath(`${projectDirectory}/${output}/.gitattributes`),
      ];
      expect(actualFilepaths.length).toEqual(expectedFiles.length);
      expect(actualFilepaths).toEqual(expect.arrayContaining(expectedFiles));
    });

    it('returns an error when a file cannot be written', async () => {
      const output = osPath(`some/output/path`);
      const generatedFile: File = {
        path: ['generated', 'file.ext'],
        contents: 'Generated content',
      };
      const engine = new Engine(
        {
          projectDirectory,
          sourcePath: 'some-file.ext',
          sourceContent: 'some content',
          parser: nullParser,
          generators: [() => [generatedFile]],
          rules: [],
          output,
        },
        new MemoryFileSystem({
          writeFile: () => {
            throw new Error('>>>> CANNOT WRITE <<<<');
          },
        }),
      );

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();
      await engine.compareFiles();
      await engine.commitFiles();

      // ASSERT
      console.log(vol.toJSON());
      expect(engine.errors).toEqual([
        {
          code: 'WRITE_ERROR',
          message: `Error writing ${osPath(
            `${output}/generated/file.ext`,
          )} (>>>> CANNOT WRITE <<<<)`,
        },
        {
          code: 'WRITE_ERROR',
          message: `Error writing ${osPath(
            `${output}/.gitattributes`,
          )} (>>>> CANNOT WRITE <<<<)`,
        },
      ]);
      const expectedFilepaths = Object.keys(vol.toJSON());
      expect(expectedFilepaths).not.toContain(
        osPath(`${projectDirectory}/${output}/generated/file.ext`),
      );
      expect(expectedFilepaths).not.toContain(
        osPath(`${projectDirectory}/${output}/.gitattributes`),
      );
    });
  });

  describe('legacy tests', () => {
    beforeEach(() => {
      setParser(() => ({
        service: {
          kind: 'Service',
          basketry: '0.2',
          title: { kind: 'StringLiteral', value: 'test' },
          majorVersion: { kind: 'IntegerLiteral', value: 1 },
          sourcePaths: ['overwritten.ext'],
          interfaces: [],
          types: [],
          enums: [],
          unions: [],
          loc: '0;0;0',
        },
        violations: [],
      }));
      setRuleViolations([]);
      setFiles([]);
    });

    it('works on the happy path', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator'],
        rules: [],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(withGitattributes(files));
    });

    it('works when a generator is supplied with generator-specific options', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: [
          'src/test-modules/generator',
          {
            generator: 'src/test-modules/generator-that-takes-options',
            options: { foo: 'bar' },
          },
        ],
        rules: [],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(
        withGitattributes([
          ...files,
          {
            path: ['with', 'options'],
            contents: '{"foo":"bar"}',
          },
        ]),
      );
    });

    it('works when a generator is supplied with common options', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: [
          'src/test-modules/generator',
          'src/test-modules/generator-that-takes-options',
        ],
        rules: [],
        validate: false,
        options: { foo: 'bar' },
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(
        withGitattributes([
          ...files,
          {
            path: ['with', 'options'],
            contents: '{"foo":"bar"}',
          },
        ]),
      );
    });

    it('works when a generator is supplied with generator-specific options that override common options', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: [
          'src/test-modules/generator',
          {
            generator: 'src/test-modules/generator-that-takes-options',
            options: { foo: 'not bar' },
          },
        ],
        rules: [],
        validate: false,
        options: { foo: 'bar' },
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(
        withGitattributes([
          ...files,
          {
            path: ['with', 'options'],
            contents: '{"foo":"not bar"}',
          },
        ]),
      );
    });

    it('works when a generator is supplied with generator-specific options that extend common options', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: [
          'src/test-modules/generator',
          {
            generator: 'src/test-modules/generator-that-takes-options',
            options: { fiz: 'buz' },
          },
        ],
        rules: [],
        validate: false,
        options: { foo: 'bar' },
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(
        withGitattributes([
          ...files,
          {
            path: ['with', 'options'],
            contents: '{"foo":"bar","fiz":"buz"}',
          },
        ]),
      );
    });

    it('works when a rule is supplied with options', async () => {
      // ARRANGE
      const files: File[] = [
        { path: ['some', 'path'], contents: 'some content' },
      ];

      setFiles(files);

      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator'],
        rules: [
          {
            rule: 'src/test-modules/rule-that-takes-options',
            options: { severity: 'info', foo: 'bar' },
          },
        ],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([
        {
          code: 'rule-that-takes-options',
          message: '{"severity":"info","foo":"bar"}',
          severity: 'info',
          range: {
            end: {
              column: 1,
              line: 1,
              offset: 0,
            },
            start: {
              column: 1,
              line: 1,
              offset: 0,
            },
          },
          sourcePath: 'some-file.ext',
        },
      ]);
      expect(engine.errors).toEqual([]);
      expect(engine.files).toEqual(withGitattributes(files));
    });

    it('returns an error when the parser module throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/module-that-throws',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/rule'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'MODULE_ERROR',
          message:
            'Error loading module "src/test-modules/module-that-throws".',
          filepath: undefined, // This would be the config path, but it's not set in this test
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns an error when a generator module throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/module-that-throws'],
        rules: ['src/test-modules/rule'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'MODULE_ERROR',
          message:
            'Error loading module "src/test-modules/module-that-throws".',
          filepath: undefined, // This would be the config path, but it's not set in this test
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns an error when a rule module throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/module-that-throws'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'MODULE_ERROR',
          message:
            'Error loading module "src/test-modules/module-that-throws".',
          filepath: undefined, // This would be the config path, but it's not set in this test
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns an error when the parser function throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser-that-throws',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/rule'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'PARSER_ERROR',
          message: 'Test error',
          filepath: 'some-file.ext',
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns an error when a generator function throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator-that-throws'],
        rules: ['src/test-modules/rule'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'GENERATOR_ERROR',
          message: 'Test error',
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns an error when a rule function throws', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/rule-that-throws'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'RULE_ERROR',
          message: 'Test error',
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns errors when the parser function returns an invalid service', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/invalid-parser',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/rule'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations).toEqual([]);
      expect(engine.errors).toEqual([
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'kind'",
        },
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'title'",
        },
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'majorVersion'",
        },
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'types'",
        },
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'enums'",
        },
        {
          code: 'PARSER_ERROR',
          message: "Invalid IR: `#` must have required property 'unions'",
        },
        {
          code: 'PARSER_ERROR',
          message: 'Invalid IR: `#` must NOT have additional properties',
        },
        {
          code: 'PARSER_ERROR',
          message: 'Invalid IR: `#/basketry` must be equal to constant',
        },
        {
          code: 'PARSER_ERROR',
          message:
            "Invalid IR: `#/interfaces/0` must have required property 'kind'",
        },
        {
          code: 'PARSER_ERROR',
          message:
            "Invalid IR: `#/interfaces/0` must have required property 'name'",
        },
        {
          code: 'PARSER_ERROR',
          message:
            "Invalid IR: `#/interfaces/0` must have required property 'methods'",
        },
        {
          code: 'PARSER_ERROR',
          message:
            'Invalid IR: `#/interfaces/0` must NOT have additional properties',
        },
      ]);
      expect(engine.files).toEqual([]);
    });

    it('returns only unique rule violations', async () => {
      // ARRANGE
      const {
        engines: [engine],
        errors,
      } = await Engine.load({
        sourcePath: 'some-file.ext',
        sourceContent: 'some content',
        parser: 'src/test-modules/parser',
        generators: ['src/test-modules/generator'],
        rules: ['src/test-modules/rule-that-returns-duplicate-violations'],
        validate: false,
      });
      expect(engine).toBeDefined();
      expect(errors).toEqual([]);

      // ACT
      await engine.runParser();
      await engine.runRules();
      await engine.runGenerators();

      // ASSERT
      expect(engine.violations.length).toEqual(1);
    });
  });
});

const nullParser: Parser = () =>
  Promise.resolve({
    service: {
      basketry: '0.2',
      kind: 'Service',
      sourcePaths: ['#'],
      title: { kind: 'StringLiteral', value: 'null' },
      majorVersion: { kind: 'IntegerLiteral', value: 1 },
      interfaces: [],
      types: [],
      enums: [],
      unions: [],
    },
    violations: [],
  });
